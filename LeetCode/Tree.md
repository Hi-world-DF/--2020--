# Tree
* 递归
    * [1.ContainsDuplicate（判断是否存在重复元素）](https://github.com/Hi-world-DF/Interview-knowledge-points/blob/master/LeetCode/Tree.md#1maximumdepthofbinarytree%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6)
    * [2.MergeTwoBinaryTrees（合并二叉树）](https://github.com/Hi-world-DF/Interview-knowledge-points/blob/master/LeetCode/Tree.md#2mergetwobinarytrees%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91)
    * [3.InvertBinaryTree（翻转二叉树）](https://github.com/Hi-world-DF/Interview-knowledge-points/blob/master/LeetCode/Tree.md#3invertbinarytree%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91)
    * [4.BalancedBinaryTree（平衡二叉树判断）](https://github.com/Hi-world-DF/Interview-knowledge-points/blob/master/LeetCode/Tree.md#4balancedbinarytree%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E5%88%A4%E6%96%AD)
    * [5.DiameterOfBinaryTree（二叉树的直径）](https://github.com/Hi-world-DF/Interview-knowledge-points/blob/master/LeetCode/Tree.md#5diameterofbinarytree%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84)
    * [6.PathSum（路径总和）](https://github.com/Hi-world-DF/Interview-knowledge-points/blob/master/LeetCode/Tree.md#6pathsum%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C)
    * [7.PathSumIII（路径总和 3）](https://github.com/Hi-world-DF/Interview-knowledge-points/blob/master/LeetCode/Tree.md#7pathsumiii%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C-3)
    * [8.LongestUniValuePath（最长同值路径）](https://github.com/Hi-world-DF/Interview-knowledge-points/blob/master/LeetCode/Tree.md#8longestunivaluepath%E6%9C%80%E9%95%BF%E5%90%8C%E5%80%BC%E8%B7%AF%E5%BE%84)
    * [9.SecondMinimumNodeInABinaryTree（间隔遍历（打家劫舍 III））](https://github.com/Hi-world-DF/Interview-knowledge-points/blob/master/LeetCode/Tree.md#9secondminimumnodeinabinarytree%E9%97%B4%E9%9A%94%E9%81%8D%E5%8E%86%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D-iii)
    * [10.SecondMinimumNodeInABinaryTree（二叉树中第二小的节点）](https://github.com/Hi-world-DF/Interview-knowledge-points/blob/master/LeetCode/Tree.md#10secondminimumnodeinabinarytree%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%AC%AC%E4%BA%8C%E5%B0%8F%E7%9A%84%E8%8A%82%E7%82%B9)
* 遍历
   * [1.BinaryTreePreOrderTraversal（二叉树的前序遍历）](https://github.com/Hi-world-DF/Interview-knowledge-points/blob/master/LeetCode/Tree.md#1binarytreepreordertraversal%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86)
   * [2.BinaryTreeInorderTraversal（二叉树的中序遍历）](https://github.com/Hi-world-DF/Interview-knowledge-points/blob/master/LeetCode/Tree.md#2binarytreeinordertraversal%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86)
   * [3.BinaryTreePostorderTraversal（二叉树的后序遍历）](https://github.com/Hi-world-DF/Interview-knowledge-points/blob/master/LeetCode/Tree.md#3binarytreepostordertraversal%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86)
   * [4.FindBottomLeftTreeValue（层次遍历--找树左下角的值）](https://github.com/Hi-world-DF/Interview-knowledge-points/blob/master/LeetCode/Tree.md#4findbottomlefttreevalue%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86--%E6%89%BE%E6%A0%91%E5%B7%A6%E4%B8%8B%E8%A7%92%E7%9A%84%E5%80%BC)
   * [5.AverageOfLevelsInBinaryTree（层次遍历--二叉树的层平均值）](https://github.com/Hi-world-DF/Interview-knowledge-points/blob/master/LeetCode/Tree.md#5averageoflevelsinbinarytree%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86--%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%B9%B3%E5%9D%87%E5%80%BC)
* BST
   * [1.ConvertBstToGreaterTree（把二叉搜索树转换为累加树）](https://github.com/Hi-world-DF/Interview-knowledge-points/blob/master/LeetCode/Tree.md#1convertbsttogreatertree%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BD%AC%E6%8D%A2%E4%B8%BA%E7%B4%AF%E5%8A%A0%E6%A0%91)
   * [2.ConvertSortedArrayToBinarySearchTree（将有序数组转换为二叉搜索树）](https://github.com/Hi-world-DF/Interview-knowledge-points/blob/master/LeetCode/Tree.md#2convertsortedarraytobinarysearchtree%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91)
   * [3.ConvertSortedListToBinarySearchTree（有序链表转换二叉搜索树）](https://github.com/Hi-world-DF/Interview-knowledge-points/blob/master/LeetCode/Tree.md#3convertsortedlisttobinarysearchtree%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E8%BD%AC%E6%8D%A2%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91)
# 递归
## 1.MaximumDepthOfBinaryTree（二叉树的最大深度）
问题描述：[LeetCode](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)   
代码：
``` java 
/**
 * 数据结构：树【递归】
 * leetcode:https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/
 * 题目描述：二叉树的最大深度
 * */

public class MaximumDepthOfBinaryTree {
    public int maxDepth(TreeNode root) {
        if(root == null){
            return 0;
        }
        int l = maxDepth(root.left);
        int r = maxDepth(root.right);
        return Math.max(l,r)+1;
    }
}
```
## 2.MergeTwoBinaryTrees（合并二叉树）
问题描述：[LeetCode](https://leetcode-cn.com/problems/merge-two-binary-trees/)   
代码：
``` java 
/**
 * 数据结构：树【递归】
 * leetcode:https://leetcode-cn.com/problems/merge-two-binary-trees/
 * 题目描述：合并二叉树
 * */
public class MergeTwoBinaryTrees {
    public TreeNode mergeTrees(TreeNode t1, TreeNode t2) {
        if(t1 == null && t2== null) return null;
        if(t1 == null) return t2;
        if(t2 == null) return t1;
        TreeNode root = new TreeNode(t1.val+t2.val);
        root.val = t1.val + t2.val;
        root.left = mergeTrees(t1.left,t2.left);
        root.right = mergeTrees(t1.right,t2.right);
        return root;
    }
}
```
## 3.InvertBinaryTree（翻转二叉树）
问题描述：[LeetCode](https://leetcode-cn.com/problems/invert-binary-tree/)   
代码：
``` java 
/**
 * 数据结构：树【递归】
 * leetcode:https://leetcode-cn.com/problems/invert-binary-tree/
 * 题目描述：翻转二叉树
 * */
public class InvertBinaryTree {
    public TreeNode invertTree(TreeNode root) {
        if(root == null){
            return null;
        }
        //先保存右子树的指针，然后让root右指针指向左子树，左指针指向右子树指针
        TreeNode right = root.right;
        root.right = invertTree(root.left);
        root.left = invertTree(right);
        return root;
    }
}
```
## 4.BalancedBinaryTree（平衡二叉树判断）
问题描述：[LeetCode](https://leetcode-cn.com/problems/balanced-binary-tree/)   
代码：
``` java 
/**
 * 数据结构：树【递归】
 * leetcode:https://leetcode-cn.com/problems/balanced-binary-tree/
 * 题目描述：平衡二叉树判断
 * */
public class BalancedBinaryTree {
    private boolean result = true;
    public boolean isBalanced(TreeNode root) {
        maxDepth(root);
        return result;
    }
    private int maxDepth(TreeNode root) {
        if(root == null){
            return 0;
        }
        int l = maxDepth(root.left);
        int r = maxDepth(root.right);
        if(Math.abs(l-r)> 1){
            result = false;
        }
        return 1 + Math.max(l,r);
    }
}
```
## 5.DiameterOfBinaryTree（二叉树的直径）
问题描述：[LeetCode](https://leetcode-cn.com/problems/diameter-of-binary-tree/)   
代码：
``` java 
/**
 * 数据结构：树【递归】
 * leetcode:https://leetcode-cn.com/problems/diameter-of-binary-tree/
 * 题目描述：二叉树的直径
 * */
public class DiameterOfBinaryTree {
    private int result = 0;
    public int diameterOfBinaryTree(TreeNode root) {
        maxDepth(root);
        return result;
    }

    private int maxDepth(TreeNode root) {
        if(root == null){
            return 0;
        }
        int l = maxDepth(root.left);
        int r = maxDepth(root.right);
        result = Math.max(result,l+r);
        return Math.max(l,r)+1;
    }
}
```
## 6.PathSum（路径总和）
问题描述：[LeetCode](https://leetcode-cn.com/problems/path-sum/)   
代码：
``` java 
/**
 * 数据结构：树【递归】
 * leetcode:https://leetcode-cn.com/problems/path-sum/
 * 题目描述：路径总和
 * */
public class PathSum {
    public boolean hasPathSum(TreeNode root, int sum) {
        if(root == null){
            return false;
        }
        if(root.right == null && root.left == null && root.val == sum){
            return true;
        }
        if(hasPathSum(root.left,sum-root.val)  || hasPathSum(root.right,sum-root.val)){
            return true;
        }
        return false;
    }
}
```
## 7.PathSumIII（路径总和 3）
问题描述：[LeetCode](https://leetcode-cn.com/problems/path-sum-iii/)   
代码：
``` java 
/**
 * 数据结构：树【递归】
 * leetcode:https://leetcode-cn.com/problems/path-sum-iii/
 * 题目描述：路径总和 3
 * */
public class PathSumIII {
    public int pathSum(TreeNode root, int sum) {
        if(root == null) return 0;
        int result =pathSumStartRoot(root,sum)+ pathSum(root.left,sum)+pathSum(root.right,sum);
        return result;
    }

    private int pathSumStartRoot(TreeNode root, int sum) {
        if(root == null) return 0;
        int result = 0;
        if(root.val == sum) result++;
        result += pathSumStartRoot(root.left,sum-root.val)+pathSumStartRoot(root.right,sum-root.val);
        return result;
    }
}
```

## 8.LongestUniValuePath（最长同值路径）
问题描述：[LeetCode](https://leetcode-cn.com/problems/longest-univalue-path/)   
代码：
``` java 
/**
 * 数据结构：树【递归】
 * leetcode:https://leetcode-cn.com/problems/longest-univalue-path/
 * 题目描述：最长同值路径
 * */
public class LongestUniValuePath {
    private int path = 0;
    public int longestUnivaluePath(TreeNode root) {
        dfs(root);
        return path;
    }
    private int dfs(TreeNode root) {
        if(root == null) return 0;
        int l = dfs(root.left);
        int r = dfs(root.right);
        int lPath = 0,rPath = 0;
        if(root.left != null && root.left.val == root.val){
            lPath = l + 1;
        }
        if(root.right != null && root.right.val == root.val){
            rPath = r + 1;
        }
        path = Math.max(path,lPath+rPath);
        return Math.max(lPath,rPath);
    }
}
```
## 9.SecondMinimumNodeInABinaryTree（间隔遍历（打家劫舍 III））
问题描述：[LeetCode](https://leetcode-cn.com/problems/house-robber-iii/)   
代码：
``` java 
/**
 * 数据结构：树【递归】
 * leetcode:https://leetcode-cn.com/problems/house-robber-iii/
 * 题目描述：间隔遍历（打家劫舍 III）
 * */
public class HouseRobberIII {
    public int rob(TreeNode root) {
        if (root == null) return 0;
        int val1 = root.val;
        if(root.left != null) val1 += rob(root.left.left) + rob(root.left.right);
        if(root.right != null) val1 += rob(root.right.left) + rob(root.right.right);
        int val2 = rob(root.left) + rob(root.right);
        return Math.max(val1,val2);
    }
}
```
## 10.SecondMinimumNodeInABinaryTree（二叉树中第二小的节点）
问题描述：[LeetCode](https://leetcode-cn.com/problems/second-minimum-node-in-a-binary-tree/)   
代码：
``` java 
/**
 * 数据结构：树【递归】
 * leetcode:https://leetcode-cn.com/problems/second-minimum-node-in-a-binary-tree/
 * 题目描述：二叉树中第二小的节点
 * */

public class SecondMinimumNodeInABinaryTree {
    public int findSecondMinimumValue(TreeNode root) {
        if(root == null) return -1;
        if(root.left == null && root.right == null) return -1;
        int lv = root.left.val;
        int rv = root.right.val;
        if(lv == root.val) lv = findSecondMinimumValue(root.left);
        if(rv == root.val) rv = findSecondMinimumValue(root.right);
        if(lv != -1 && rv != -1) return Math.min(lv,rv);
        if(lv != -1) return lv;
        if(rv != -1) return rv;
        return -1;
    }
}
```
# 遍历

## 1.BinaryTreePreOrderTraversal（二叉树的前序遍历）
问题描述：[LeetCode](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/)   
代码：
``` java 
import java.util.ArrayList;
import java.util.List;
import java.util.Stack;

/**
 * 数据结构：树【遍历】
 * leetcode:https://leetcode-cn.com/problems/binary-tree-preorder-traversal/
 * 题目描述：二叉树的前序遍历
 * */

public class BinaryTreePreOrderTraversal {
    /**递归*/
    /** void dfs(TreeNode root) {
        visit(root);
        dfs(root.left);
        dfs(root.right);
    }*/
    public List<Integer> preOrderTraversal(TreeNode root) {
        List<Integer> resultList = new ArrayList<>();
        Stack<TreeNode> stack = new Stack<>();
        if(root == null) return resultList;
        stack.push(root);
        while(!stack.isEmpty()){
            TreeNode node = stack.pop();
            if(node == null) continue;
            resultList.add(node.val);
            stack.push(node.right);
            stack.push(node.left);
        }
        return resultList;
    }
}
```
## 2.BinaryTreeInorderTraversal（二叉树的中序遍历）
问题描述：[LeetCode](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/)   
代码：
``` java 
import java.util.ArrayList;
import java.util.List;
import java.util.Stack;

/**
 * 数据结构：树【遍历】
 * leetcode:https://leetcode-cn.com/problems/binary-tree-inorder-traversal/
 * 题目描述：二叉树的中序遍历
 * */
public class BinaryTreeInorderTraversal {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> resultList = new ArrayList<>();
        Stack<TreeNode> stack = new Stack<>();
        if(root == null) return resultList;
        TreeNode currentNode = root;
        while(currentNode != null || !stack.isEmpty()){
            while(currentNode != null){
                stack.push(currentNode);
                currentNode = currentNode.left;
            }
            TreeNode node = stack.pop();
            resultList.add(node.val);
            currentNode = node.right;
        }
        return resultList;
    }
}
```
## 3.BinaryTreePostorderTraversal（二叉树的后序遍历）
问题描述：[LeetCode](https://leetcode-cn.com/problems/binary-tree-postorder-traversal/)   
代码：
``` java 
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Stack;

/**
 * 数据结构：树【遍历】
 * leetcode:https://leetcode-cn.com/problems/binary-tree-postorder-traversal/
 * 题目描述：二叉树的后序遍历
 * */
public class BinaryTreePostorderTraversal {
    public List<Integer> postorderTraversal(TreeNode root) {
        List<Integer> resultList = new ArrayList<>();
        Stack<TreeNode> stack = new Stack<>();
        if(root == null) return resultList;
        stack.push(root);
        while(!stack.isEmpty()){
            TreeNode node = stack.pop();
            if(node == null) continue;
            resultList.add(node.val);
            stack.push(node.left);
            stack.push(node.right);
        }
        Collections.reverse(resultList);
        return resultList;
    }
}
```
## 4.FindBottomLeftTreeValue（层次遍历--找树左下角的值）
问题描述：[LeetCode](https://leetcode-cn.com/problems/find-bottom-left-tree-value/)   
代码：
``` java 
import java.util.LinkedList;
import java.util.Queue;

/**
 * 数据结构：树【层次遍历】
 * leetcode:https://leetcode-cn.com/problems/find-bottom-left-tree-value/
 * 题目描述：找树左下角的值
 * */

public class FindBottomLeftTreeValue {
    public int findBottomLeftValue(TreeNode root) {
        Queue<TreeNode> queue = new LinkedList<>();
        queue.add(root);
        while(!queue.isEmpty()){
            root = queue.poll();
            if(root.right != null) queue.add(root.right);
            if(root.left != null) queue.add(root.left);
        }
        return root.val;
    }
}
```
## 5.AverageOfLevelsInBinaryTree（层次遍历--二叉树的层平均值）
问题描述：[LeetCode](https://leetcode-cn.com/problems/average-of-levels-in-binary-tree/)   
代码：
``` java 
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;

/**
 * 数据结构：树【层次遍历】
 * leetcode:https://leetcode-cn.com/problems/average-of-levels-in-binary-tree/
 * 题目描述：二叉树的层平均值
 * */
public class AverageOfLevelsInBinaryTree {
    public List<Double> averageOfLevels(TreeNode root) {
        List<Double> result = new ArrayList<>();
        Queue<TreeNode> queue = new LinkedList<>();
        if(root == null) return result;
        queue.add(root);
        while(!queue.isEmpty()){
            double sum = 0;
            int currentL = queue.size();
            for (int i = 0; i < currentL; i++) {
                TreeNode node = queue.poll();
                sum += node.val;
                if (node.left != null) queue.add(node.left);
                if (node.right != null) queue.add(node.right);
            }
            result.add(sum / currentL);
        }
        return result;
    }
}
```
# BST
## 1.ConvertBstToGreaterTree（把二叉搜索树转换为累加树）
问题描述：[LeetCode](https://leetcode-cn.com/problems/convert-bst-to-greater-tree/)   
代码：
``` java 
/**
 * 数据结构：树【BST 二叉查找树】
 * leetcode:https://leetcode-cn.com/problems/convert-bst-to-greater-tree/
 * 题目描述：把二叉搜索树转换为累加树
 * */
public class ConvertBstToGreaterTree {
    private int sum = 0;
    public TreeNode convertBST(TreeNode root) {
        traver(root);
        return root;
    }

    private void traver(TreeNode node) {
        if(node == null) return;
        traver(node.right);
        sum += node.val;
        node.val = sum;
        traver(node.left);
    }
}
```

## 2.ConvertSortedArrayToBinarySearchTree（将有序数组转换为二叉搜索树）
问题描述：[LeetCode](https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/)   
代码：
``` java 
/**
 * 数据结构：树【BST 二叉查找树】
 * leetcode:https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/
 * 题目描述：将有序数组转换为二叉搜索树
 * */
public class ConvertSortedArrayToBinarySearchTree {
    public TreeNode sortedArrayToBST(int[] nums) {
        return toBST(nums,0,nums.length -1);
    }

    private TreeNode toBST(int[] nums, int start, int end) {
        if(start > end) return null;
        int mid = (start + end) / 2;
        TreeNode root = new TreeNode(nums[mid]);
        root.left = toBST(nums,start,mid -1);
        root.right = toBST(nums,mid +1,end);
        return root;
    }

}
```
## 3.ConvertSortedListToBinarySearchTree（有序链表转换二叉搜索树）
问题描述：[LeetCode](https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/)   
代码：
``` java 
/**
 * 数据结构：树【BST 二叉查找树】
 * leetcode:https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/
 * 题目描述：有序链表转换二叉搜索树
 * */
public class ConvertSortedListToBinarySearchTree {
    public TreeNode sortedListToBST(ListNode head) {
        if(head == null) return null;
        if(head.next == null) return new TreeNode(head.val);
        ListNode preMid = preMid(head);
        ListNode mid = preMid.next;
        preMid.next = null;
        TreeNode treeNode = new TreeNode(mid.val);
        treeNode.left = sortedListToBST(head);
        treeNode.right = sortedListToBST(mid.next);
        return treeNode;
    }

    private ListNode preMid(ListNode head) {
        ListNode first = head,last = head.next;
        ListNode pre = head;
        while(last != null && last.next != null){
            pre = first;
            first = first.next;
            last = last.next.next;
        }
        return pre;
    }
}
```
